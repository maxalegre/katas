cmdhistory=["\\n(reduce (fn [a b] a) [1 2 3 4 5 6])" "(reduce (fn [a b] b) [1 2 3 4 5 6])" "\\n(reduce (fn [a b] (if (< (last a) b) (conj a \:menor b) (a))) [1 2 3 4 5 6])" "\\n(\:a \:b \:c)" "(\\"Sd\\" \\"sda\\" \\"sada\\")" "(1 2 3 4)" "(conj 1 2 3)" "(reduce (fn [a b] (if (< (last a) b) (conj '(a) \:menor b) (a))) [1 2 3 4 5 6])" "(reduce (fn [a b] (if (< (last a) b) (conj '(1) \:menor b) (a))) [1 2 3 4 5 6])" "(reduce (fn [a b] (if (< 1 b) (conj '(a) \:menor b) (a))) [1 2 3 4 5 6])" "(reduce (fn [a b] (if (< 1 b) (str (a + b)) (a))) [1 2 3 4 5 6])" "(reduce (fn [a b] (if (< 1 b) (str (+ a b)) (a))) [1 2 3 4 5 6])" "\\n(reduce (fn [a b] (if (< 1 b) (str a b) (a))) [1 2 3 4 5 6])" "\\n(reduce (fn [a b] (if (< 1 b) (str a \:menor b) (a))) [1 2 3 4 5 6])" "(concat 1 2 3)" "(concat 1 \:menor 2)" "(concat \\"av\\" 1)" "(concat (list \\"av\\") 1)" "(list \\"av\\")" "(def hello '(1 2 3))" "hello" "(concat hello 5 6)" "(concat (list hello))" "(list hello)" "(concat (list hello) (3))" "(concat (list hello) '(3))" "(cons 1 2 3 4)" "(cons 1 '(2 3 4))" "(cons '(1 2) '(3 4))" "(list \:menor \\"b\\")" "(list b)" "(list \\"b\\")" "(defn intercalar\\r\\n  \\"Escriba una funcion que tome un predicado de 2 argumentos, un valor y una coleccion, y\\r\\n   retorne una nueva coleccion donde el valor es insertado intercalado cada dos argumentos\\r\\n   que cumplan el predicado\\"\\r\\n  [predicado valor secuencia]\\r\\n  (reduce (fn [a b] \\r\\n            (if (< (last a) b) \\r\\n              (if (list? a) \\r\\n                (conj a (list \:menor b)) \\r\\n                (cons a (list \:menor b))) \\r\\n              (if (list? a) \\r\\n                (conj a (list b)) \\r\\n                (cons a (list b)))\\r\\n              )\\r\\n            ) secuencia)\\r\\n  )" "(intercalar a b [1 2 3 4 5])" "(reduce (fn [a b] \\r\\n            (if (< (last a) b) \\r\\n              (if (list? a) \\r\\n                (conj a (list \:menor b)) \\r\\n                (cons a (list \:menor b))) \\r\\n              (if (list? a) \\r\\n                (conj a (list b)) \\r\\n                (cons a (list b)))\\r\\n              )\\r\\n            ) [1 2 3 4 5])" "\\n(let [x [1 2 3 4 5]] [(* 2 x)])" "\\n(let [x [1 2 3 4 5]] (* 2 x))" "\\n\\n(let [x (range 5)] (* 2 x))" "\\n\\n(let [x (range 5)] (* 2 (first x)))" "\\n(let [x (range 5)] (* 2 (last x)))" "\\n\\n(let [x (range 5)] [(* 2 (last x))])" "\\n\\n(let [x (range 5)] [x])" "(let [x (range 5)] x)" "(defn simple-range [i limit]\\r\\n (lazy-seq\\r\\n (when (< i limit)\\r\\n (cons i (simple-range (inc i)\\r\\n limit)))))" "(simple-range 2 6)" "(cons 1 (list 2 3 4))" "(cons 1 (list 2 3) (list 4 5))" "(cons (list 1 2) (list 3 4))" "(conj (list 1 2) (list 3 4))" "(concat 1 (list 2 3 4))" "(concat (1) (1 2 3))" "(concat (list 1 2) (list 1 2 3) (list 5))" "(defn simple-range [secuencia]\\r\\n  (lazy-seq\\r\\n    (if (< (first secuencia) (second secuencia))\\r\\n      (concat (list (first secuencia) \:menor) (simple-range (rest secuencia)))\\r\\n      (cons (first secuencia) (simple-range (rest secuencia)))\\r\\n      )\\r\\n    )\\r\\n  )" "(rest (list 1 2 3 4 5))" "(defn simple-range [secuencia]\\r\\n  (lazy-seq\\r\\n    (if (< (first secuencia) (second secuencia))\\r\\n      (concat (list (first secuencia) \:menor) (simple-range (rest secuencia)))\\r\\n      (cons (first secuencia) (simple-range (rest secuencia)))\\r\\n      )\\r\\n    )\\r\\n  )" "(simple-range [1 2 3 4])" "(defn simple-range [secuencia]\\r\\n  (lazy-seq\\r\\n    (if (not\= (count secuencia) 1)\\r\\n      (if (< (first secuencia) (second secuencia))\\r\\n        (concat (list (first secuencia) \:menor) (simple-range (rest secuencia)))\\r\\n        (cons (first secuencia) (simple-range (rest secuencia)))\\r\\n        )\\r\\n      (first secuencia)\\r\\n      )\\r\\n    )\\r\\n  )" "(simple-range [1 2 3 4 5])" "(defn simple-range [secuencia]\\r\\n  (lazy-seq\\r\\n    (if (not\= (count secuencia) 1)\\r\\n      (if (< (first secuencia) (second secuencia))\\r\\n        (concat (list (first secuencia) \:menor) (simple-range (rest secuencia)))\\r\\n        (cons (first secuencia) (simple-range (rest secuencia)))\\r\\n        )\\r\\n      (list secuencia)\\r\\n      )\\r\\n    )\\r\\n  )" "(simple-range [1 2 3 4 5])" "(simple-range [2 3 1 6 4])" "(defn simple-range [secuencia]\\r\\n  (lazy-seq\\r\\n    (if (not\= (count secuencia) 1)\\r\\n      (if (< (first secuencia) (second secuencia))\\r\\n        (concat (list (first secuencia) \:menor) (simple-range (rest secuencia)))\\r\\n        (cons (first secuencia) (simple-range (rest secuencia)))\\r\\n        )\\r\\n      (secuencia)\\r\\n      )\\r\\n    )\\r\\n  )" "(simple-range [2 3 1 6 4 5])" "(defn simple-range [secuencia]\\r\\n  (lazy-seq\\r\\n    (if (not\= (count secuencia) 1)\\r\\n      (if (< (first secuencia) (second secuencia))\\r\\n        (concat (list (first secuencia) \:menor) (simple-range (rest secuencia)))\\r\\n        (cons (first secuencia) (simple-range (rest secuencia)))\\r\\n        )\\r\\n      secuencia\\r\\n      )\\r\\n    )\\r\\n  )" "(simple-range [2 3 1 6 4 5])" "(defn intercalar\\r\\n  \\"Escriba una funcion que tome un predicado de 2 argumentos, un valor y una coleccion, y\\r\\n   retorne una nueva coleccion donde el valor es insertado intercalado cada dos argumentos\\r\\n   que cumplan el predicado\\"\\r\\n  [predicado valor secuencia]\\r\\n  \\r\\n  (lazy-seq\\r\\n    (if (not\= (count secuencia) 1)\\r\\n      (if (predicado (first secuencia) (second secuencia))\\r\\n        (concat (list (first secuencia) valor) (simple-range (rest secuencia)))\\r\\n        (cons (first secuencia) (simple-range (rest secuencia)))\\r\\n        )\\r\\n      secuencia\\r\\n      )\\r\\n    )\\r\\n  \\r\\n  )" "(intercalar \= \:igual [1 2 2 3 4 4 5])" "(intercalar \= \:igual [1 5 3 4 8 5])" "(simple-range [1 2 2 3 4 4 5])" "(simple-range [1 5 3 4 8 5])" "(defn intercalar\\r\\n  \\"Escriba una funcion que tome un predicado de 2 argumentos, un valor y una coleccion, y\\r\\n   retorne una nueva coleccion donde el valor es insertado intercalado cada dos argumentos\\r\\n   que cumplan el predicado\\"\\r\\n  [predicado valor secuencia]\\r\\n  \\r\\n  (lazy-seq\\r\\n    (if (not\= (count secuencia) 1)\\r\\n      (if (predicado (first secuencia) (second secuencia))\\r\\n        (concat (list (first secuencia) valor) (simple-range (rest secuencia)))\\r\\n        (cons (first secuencia) (simple-range (rest secuencia)))\\r\\n        )\\r\\n      secuencia\\r\\n      )\\r\\n    )\\r\\n  )" "(intercalar [12 32 42 2])" "(intercalar < \:menor [1 2 3 2 4 2 2])" "(intercalar > \:mayor [1 2 3 2 4 2 0])" "(intercalar < \:mesdanor [1 2 3 2 4 2 2])" "(defn intercalar\\r\\n  \\"Escriba una funcion que tome un predicado de 2 argumentos, un valor y una coleccion, y\\r\\n   retorne una nueva coleccion donde el valor es insertado intercalado cada dos argumentos\\r\\n   que cumplan el predicado\\"\\r\\n  [predicado valor secuencia]\\r\\n  \\r\\n  (lazy-seq\\r\\n    (if (not\= (count secuencia) 1)\\r\\n      (if (predicado (first secuencia) (second secuencia))\\r\\n        (concat (list (first secuencia) valor) (intercalar (rest secuencia)))\\r\\n        (cons (first secuencia) (intercalar (rest secuencia)))\\r\\n        )\\r\\n      secuencia\\r\\n      )\\r\\n    )\\r\\n  )" "(intercalar \= \:igual [1 2 2 3 4 4 5])" "(intercalar [1 2 2 3 4 4 5])" "(intercalar \= \:igual [1 2 2 3 4 4 5])" "(defn intercalar\\r\\n  \\"Escriba una funcion que tome un predicado de 2 argumentos, un valor y una coleccion, y\\r\\n   retorne una nueva coleccion donde el valor es insertado intercalado cada dos argumentos\\r\\n   que cumplan el predicado\\"\\r\\n  [predicado valor secuencia]\\r\\n  \\r\\n  (lazy-seq\\r\\n    (if (not\= (count secuencia) 1)\\r\\n      (if (predicado (first secuencia) (second secuencia))\\r\\n        (concat (list (first secuencia) valor) (intercalar predicado valor (rest secuencia)))\\r\\n        (cons (first secuencia) (intercalar predicado valor (rest secuencia)))\\r\\n        )\\r\\n      secuencia\\r\\n      )\\r\\n    )\\r\\n  )" "(intercalar \= \:igual [1 2 2 3 4 4 5])" "(defn search\\r\\n  \\"Dado un numero cualquiera de secuencias, cada una ya ordenada de menor a mayor, encontrar el numero\\r\\n   mas chico que aparezca en todas las secuencias, las secuencias pueden ser infinitas.\\"\\r\\n  [& seqs]\\r\\n  (for [x (first seqs)]\\r\\n    x\\r\\n    \\r\\n    )\\r\\n  )" "(search [[1 2 3][4 5 6]])" "(search [1 2 3][4 5 6])" "(contains? '(1 2 3) 1)" "(contains? (set '(101 102 103)) 102)" "(contains? (set '(101 102 103)) 105)" "(contains? (set '(101 102 103)) 103)" "(contains? (set [101 102 103]) 102)" "(contains? (set [101 102 103]) 105)" "(defn true-false [x secuencias]\\r\\n    (for [y secuencias]\\r\\n      (if (contains? (set y) x)\\r\\n        true\\r\\n        )\\r\\n      )\\r\\n    \\r\\n    )" "(true-false 1 [[2 3][4 5][1 6]])" "(for [x (count [[2 3][4 5][1 6]])]\\r\\n    (for [z (first [[2 3][4 5][1 6]])]\\r\\n      (true-false z (rest [[2 3][4 5][1 6]]))    \\r\\n      )\\r\\n    )" "(for [z (first seqs)]\\r\\n    (true-false z (rest seqs))    \\r\\n    )" "(for [z (first [[2 3][4 5][1 6]])]\\r\\n    (true-false z (rest [[2 3][4 5][1 6]]))    \\r\\n    )" "(conj (list 1 2 3) (list 4 5))" "(concat (list 1 2 3) (list 4 5))" "(concat (list (rest (list 1 2 3)) (list (list 4 5) (list 6 7))))" "(+ 2 2)" "(contains? (set [1 2 3]) 2)" "(contains? (set [1 2 3 5]) 4)" "(contains? (set (list 1 2 3)) 2)" "(contains? (set (list 1 2 3)) 4)" "(contains? (set (list (list 1 2 3) (list 4 5))) 4)" "(defn true-false [x secuencia]\\r\\n    (lazy-seq\\r\\n      (for [y secuencia]\\r\\n        (contains? (set y) x)\\r\\n        )\\r\\n      )\\r\\n    )" "(true-false 2 (list (list 3 4) (list 4 2) (list 2 2)))" "(defn true-false [x secuencia]\\r\\n    (for [y secuencia]\\r\\n      (contains? (set y) x)\\r\\n      )\\r\\n    )" "(true-false 2 (list (list 3 4) (list 4 2) (list 2 2)))" "(defn true-false [x secuencia]\\r\\n    (for [y secuencia]\\r\\n      (contains? (set y) x)\\r\\n      )\\r\\n    )" "(true-false 3 (list (list 1 2 3) (list 3 3 1) (list 2 2 13232)))" "(defn hello [& seqs] seqs)" "(hello (list 1 2) (list 3 4) (list 5 6))" "(rest (list 1 2) (list 3 4) (list 5 6))" "(rest (list (list 1 2) (list 3 4) (list 5 6)))" "(concat (rest (first (list (list 1 2) (list 3 4) (list 5 6)))) (rest (list (list 1 2) (list 3 4) (list 5 6))))" "(concat (rest (first (list (list 0 1 2) (list 3 4) (list 5 6)))) (rest (list (list 1 2) (list 3 4) (list 5 6))))" "(defn search\\r\\n  \\"Dado un numero cualquiera de secuencias, cada una ya ordenada de menor a mayor, encontrar el numero\\r\\n   mas chico que aparezca en todas las secuencias, las secuencias pueden ser infinitas.\\"\\r\\n  [& seqs]\\r\\n  \\r\\n  (defn true-false [x secuencia]\\r\\n    (for [y secuencia]\\r\\n      (contains? (set y) x)\\r\\n      )\\r\\n    )\\r\\n  \\r\\n  (if (some false? (true-false (first (first seqs)) (rest seqs)))\\r\\n    (search (concat (list (rest (first seqs)))) (rest seqs))\\r\\n    (first (first seqs))\\r\\n    )\\r\\n  )" "(search (list 1 2 3 4 5) (list 3 4) (list 0 1 2 4))" "(defn search\\r\\n     [& seqs]\\r\\n     \\r\\n     (defn true-false [x secuencia]\\r\\n       (for [y secuencia]\\r\\n         (contains? (set y) x)\\r\\n         )\\r\\n       )\\r\\n     \\r\\n     (if (some false? (true-false (first (first seqs)) (rest seqs)))\\r\\n       \\"Hola\\"\\r\\n       (first (first seqs))\\r\\n       )\\r\\n     )" "(search (list 1 2 3 4 5) (list 3 4) (list 0 1 2 4))" "(search (list 1 2 3 4 5) (list 3 1) (list 0 1 2 4))" "(rest (list 1 2 3 4 5) (list 3 1) (list 0 1 2 4))" "(hello (list 1 2 3 4 5) (list 3 1) (list 0 1 2 4))" "(rest (list (list 1 2 3 4 5) (list 3 1) (list 0 1 2 4)))" "(defn hello [& seqs] (rest seqs))" "(hello (list 1 2 3 4 5) (list 3 1) (list 0 1 2 4))" "(defn hello [& seqs] (drop 1 seqs))" "(hello (list 1 2 3 4 5) (list 3 1) (list 0 1 2 4))" "(defn foo [x]\\r\\n        (if (< x 0)\\r\\n          (println \\"done\\")\\r\\n          \#(foo (do (println \:x x) (dec x)))))" "(trampoline foo 10)" "(defn true-false [x secuencia]\\r\\n    (for [y secuencia]\\r\\n      (contains? (set y) x)\\r\\n      )\\r\\n    )" "(defn search [& seqs] (if (some false? (true-false (first (first seqs)) (rest seqs)))\\r\\n    (trampoline search (concat (list (rest (first seqs)))) (rest seqs))\\r\\n    (first (first seqs))\\r\\n    ))" "(search (list 1 2 3) (list 2 3) (list 2))" "(defn search [& seqs] (if (some false? (true-false (first (first seqs)) (rest seqs)))\\r\\n       (search (concat (list (rest (first seqs)))) (rest seqs))\\r\\n       (first (first seqs))\\r\\n       ))" "(trampoline (list 1 2 3) (list 2 3) (list 2))" "(defn search [& seqs] \\n  (if (some false? (true-false (first (first seqs)) (rest seqs)))\\r\\n          \#(search (concat (list (rest (first seqs)))) (rest seqs))\\r\\n          (first (first seqs))\\r\\n          ))" "(trampoline search (list 1 2 3) (list 2 3) (list 2))" "(search (list 1 2 3) (list 2 3) (list 2))" "(defn search [& seqs] \\r\\n     (if (some false? (true-false (first (first seqs)) (rest seqs)))\\r\\n             \#(search (concat (list (rest (first seqs)))) (rest seqs))\\r\\n             (println (first (first seqs)))\\r\\n             ))" "(trampoline search (list 1 2 3) (list 2 3))" "(concat (list (rest (first (list (list 1 2 3) (list 2 3) (list 2 3))))) (rest (list (list 1 2 3) (list 2 3) (list 2 3))))" "(defn hello [& se] se)" "(hello (list (list 1 2 3) (list 4 5) (list 6 7)))" "(defn search2 [secuencias]\\r\\n    (if (some false? (true-false (first (first secuencias)) (rest secuencias)))\\r\\n      \#(search2 (concat (list (rest (first secuencias))) (rest secuencias)))\\r\\n      (first (first secuencias))\\r\\n      )\\r\\n    )" "(trampoline search2 (list 1 2 3) (list 2 3) (list 1 2))" "(trampoline search2 (list (list 1 2 3) (list 2 3) (list 1 2)))" "(trampoline search2 (list (list 1 2 3 4 5 6) (list 2 4 5) (list 0 1 3 5)))"]
eclipse.preferences.version=1
