cmdhistory=["\\n(reduce (fn [a b] a) [1 2 3 4 5 6])" "(reduce (fn [a b] b) [1 2 3 4 5 6])" "\\n(reduce (fn [a b] (if (< (last a) b) (conj a \:menor b) (a))) [1 2 3 4 5 6])" "\\n(\:a \:b \:c)" "(\\"Sd\\" \\"sda\\" \\"sada\\")" "(1 2 3 4)" "(conj 1 2 3)" "(reduce (fn [a b] (if (< (last a) b) (conj '(a) \:menor b) (a))) [1 2 3 4 5 6])" "(reduce (fn [a b] (if (< (last a) b) (conj '(1) \:menor b) (a))) [1 2 3 4 5 6])" "(reduce (fn [a b] (if (< 1 b) (conj '(a) \:menor b) (a))) [1 2 3 4 5 6])" "(reduce (fn [a b] (if (< 1 b) (str (a + b)) (a))) [1 2 3 4 5 6])" "(reduce (fn [a b] (if (< 1 b) (str (+ a b)) (a))) [1 2 3 4 5 6])" "\\n(reduce (fn [a b] (if (< 1 b) (str a b) (a))) [1 2 3 4 5 6])" "\\n(reduce (fn [a b] (if (< 1 b) (str a \:menor b) (a))) [1 2 3 4 5 6])" "(concat 1 2 3)" "(concat 1 \:menor 2)" "(concat \\"av\\" 1)" "(concat (list \\"av\\") 1)" "(list \\"av\\")" "(def hello '(1 2 3))" "hello" "(concat hello 5 6)" "(concat (list hello))" "(list hello)" "(concat (list hello) (3))" "(concat (list hello) '(3))" "(cons 1 2 3 4)" "(cons 1 '(2 3 4))" "(cons '(1 2) '(3 4))" "(list \:menor \\"b\\")" "(list b)" "(list \\"b\\")" "(defn intercalar\\r\\n  \\"Escriba una funcion que tome un predicado de 2 argumentos, un valor y una coleccion, y\\r\\n   retorne una nueva coleccion donde el valor es insertado intercalado cada dos argumentos\\r\\n   que cumplan el predicado\\"\\r\\n  [predicado valor secuencia]\\r\\n  (reduce (fn [a b] \\r\\n            (if (< (last a) b) \\r\\n              (if (list? a) \\r\\n                (conj a (list \:menor b)) \\r\\n                (cons a (list \:menor b))) \\r\\n              (if (list? a) \\r\\n                (conj a (list b)) \\r\\n                (cons a (list b)))\\r\\n              )\\r\\n            ) secuencia)\\r\\n  )" "(intercalar a b [1 2 3 4 5])" "(reduce (fn [a b] \\r\\n            (if (< (last a) b) \\r\\n              (if (list? a) \\r\\n                (conj a (list \:menor b)) \\r\\n                (cons a (list \:menor b))) \\r\\n              (if (list? a) \\r\\n                (conj a (list b)) \\r\\n                (cons a (list b)))\\r\\n              )\\r\\n            ) [1 2 3 4 5])" "\\n(let [x [1 2 3 4 5]] [(* 2 x)])" "\\n(let [x [1 2 3 4 5]] (* 2 x))" "\\n\\n(let [x (range 5)] (* 2 x))" "\\n\\n(let [x (range 5)] (* 2 (first x)))" "\\n(let [x (range 5)] (* 2 (last x)))" "\\n\\n(let [x (range 5)] [(* 2 (last x))])" "\\n\\n(let [x (range 5)] [x])" "(let [x (range 5)] x)" "(defn simple-range [i limit]\\r\\n (lazy-seq\\r\\n (when (< i limit)\\r\\n (cons i (simple-range (inc i)\\r\\n limit)))))" "(simple-range 2 6)" "(cons 1 (list 2 3 4))" "(cons 1 (list 2 3) (list 4 5))" "(cons (list 1 2) (list 3 4))" "(conj (list 1 2) (list 3 4))" "(concat 1 (list 2 3 4))" "(concat (1) (1 2 3))" "(concat (list 1 2) (list 1 2 3) (list 5))" "(defn simple-range [secuencia]\\r\\n  (lazy-seq\\r\\n    (if (< (first secuencia) (second secuencia))\\r\\n      (concat (list (first secuencia) \:menor) (simple-range (rest secuencia)))\\r\\n      (cons (first secuencia) (simple-range (rest secuencia)))\\r\\n      )\\r\\n    )\\r\\n  )" "(rest (list 1 2 3 4 5))" "(defn simple-range [secuencia]\\r\\n  (lazy-seq\\r\\n    (if (< (first secuencia) (second secuencia))\\r\\n      (concat (list (first secuencia) \:menor) (simple-range (rest secuencia)))\\r\\n      (cons (first secuencia) (simple-range (rest secuencia)))\\r\\n      )\\r\\n    )\\r\\n  )" "(simple-range [1 2 3 4])" "(defn simple-range [secuencia]\\r\\n  (lazy-seq\\r\\n    (if (not\= (count secuencia) 1)\\r\\n      (if (< (first secuencia) (second secuencia))\\r\\n        (concat (list (first secuencia) \:menor) (simple-range (rest secuencia)))\\r\\n        (cons (first secuencia) (simple-range (rest secuencia)))\\r\\n        )\\r\\n      (first secuencia)\\r\\n      )\\r\\n    )\\r\\n  )" "(simple-range [1 2 3 4 5])" "(defn simple-range [secuencia]\\r\\n  (lazy-seq\\r\\n    (if (not\= (count secuencia) 1)\\r\\n      (if (< (first secuencia) (second secuencia))\\r\\n        (concat (list (first secuencia) \:menor) (simple-range (rest secuencia)))\\r\\n        (cons (first secuencia) (simple-range (rest secuencia)))\\r\\n        )\\r\\n      (list secuencia)\\r\\n      )\\r\\n    )\\r\\n  )" "(simple-range [1 2 3 4 5])" "(simple-range [2 3 1 6 4])" "(defn simple-range [secuencia]\\r\\n  (lazy-seq\\r\\n    (if (not\= (count secuencia) 1)\\r\\n      (if (< (first secuencia) (second secuencia))\\r\\n        (concat (list (first secuencia) \:menor) (simple-range (rest secuencia)))\\r\\n        (cons (first secuencia) (simple-range (rest secuencia)))\\r\\n        )\\r\\n      (secuencia)\\r\\n      )\\r\\n    )\\r\\n  )" "(simple-range [2 3 1 6 4 5])" "(defn simple-range [secuencia]\\r\\n  (lazy-seq\\r\\n    (if (not\= (count secuencia) 1)\\r\\n      (if (< (first secuencia) (second secuencia))\\r\\n        (concat (list (first secuencia) \:menor) (simple-range (rest secuencia)))\\r\\n        (cons (first secuencia) (simple-range (rest secuencia)))\\r\\n        )\\r\\n      secuencia\\r\\n      )\\r\\n    )\\r\\n  )" "(simple-range [2 3 1 6 4 5])" "(defn intercalar\\r\\n  \\"Escriba una funcion que tome un predicado de 2 argumentos, un valor y una coleccion, y\\r\\n   retorne una nueva coleccion donde el valor es insertado intercalado cada dos argumentos\\r\\n   que cumplan el predicado\\"\\r\\n  [predicado valor secuencia]\\r\\n  \\r\\n  (lazy-seq\\r\\n    (if (not\= (count secuencia) 1)\\r\\n      (if (predicado (first secuencia) (second secuencia))\\r\\n        (concat (list (first secuencia) valor) (simple-range (rest secuencia)))\\r\\n        (cons (first secuencia) (simple-range (rest secuencia)))\\r\\n        )\\r\\n      secuencia\\r\\n      )\\r\\n    )\\r\\n  \\r\\n  )" "(intercalar \= \:igual [1 2 2 3 4 4 5])" "(intercalar \= \:igual [1 5 3 4 8 5])" "(simple-range [1 2 2 3 4 4 5])" "(simple-range [1 5 3 4 8 5])" "(defn intercalar\\r\\n  \\"Escriba una funcion que tome un predicado de 2 argumentos, un valor y una coleccion, y\\r\\n   retorne una nueva coleccion donde el valor es insertado intercalado cada dos argumentos\\r\\n   que cumplan el predicado\\"\\r\\n  [predicado valor secuencia]\\r\\n  \\r\\n  (lazy-seq\\r\\n    (if (not\= (count secuencia) 1)\\r\\n      (if (predicado (first secuencia) (second secuencia))\\r\\n        (concat (list (first secuencia) valor) (simple-range (rest secuencia)))\\r\\n        (cons (first secuencia) (simple-range (rest secuencia)))\\r\\n        )\\r\\n      secuencia\\r\\n      )\\r\\n    )\\r\\n  )" "(intercalar [12 32 42 2])" "(intercalar < \:menor [1 2 3 2 4 2 2])" "(intercalar > \:mayor [1 2 3 2 4 2 0])" "(intercalar < \:mesdanor [1 2 3 2 4 2 2])" "(defn intercalar\\r\\n  \\"Escriba una funcion que tome un predicado de 2 argumentos, un valor y una coleccion, y\\r\\n   retorne una nueva coleccion donde el valor es insertado intercalado cada dos argumentos\\r\\n   que cumplan el predicado\\"\\r\\n  [predicado valor secuencia]\\r\\n  \\r\\n  (lazy-seq\\r\\n    (if (not\= (count secuencia) 1)\\r\\n      (if (predicado (first secuencia) (second secuencia))\\r\\n        (concat (list (first secuencia) valor) (intercalar (rest secuencia)))\\r\\n        (cons (first secuencia) (intercalar (rest secuencia)))\\r\\n        )\\r\\n      secuencia\\r\\n      )\\r\\n    )\\r\\n  )" "(intercalar \= \:igual [1 2 2 3 4 4 5])" "(intercalar [1 2 2 3 4 4 5])" "(intercalar \= \:igual [1 2 2 3 4 4 5])" "(defn intercalar\\r\\n  \\"Escriba una funcion que tome un predicado de 2 argumentos, un valor y una coleccion, y\\r\\n   retorne una nueva coleccion donde el valor es insertado intercalado cada dos argumentos\\r\\n   que cumplan el predicado\\"\\r\\n  [predicado valor secuencia]\\r\\n  \\r\\n  (lazy-seq\\r\\n    (if (not\= (count secuencia) 1)\\r\\n      (if (predicado (first secuencia) (second secuencia))\\r\\n        (concat (list (first secuencia) valor) (intercalar predicado valor (rest secuencia)))\\r\\n        (cons (first secuencia) (intercalar predicado valor (rest secuencia)))\\r\\n        )\\r\\n      secuencia\\r\\n      )\\r\\n    )\\r\\n  )" "(intercalar \= \:igual [1 2 2 3 4 4 5])" "(defn search\\r\\n  \\"Dado un numero cualquiera de secuencias, cada una ya ordenada de menor a mayor, encontrar el numero\\r\\n   mas chico que aparezca en todas las secuencias, las secuencias pueden ser infinitas.\\"\\r\\n  [& seqs]\\r\\n  (for [x (first seqs)]\\r\\n    x\\r\\n    \\r\\n    )\\r\\n  )" "(search [[1 2 3][4 5 6]])" "(search [1 2 3][4 5 6])" "(contains? '(1 2 3) 1)" "(contains? (set '(101 102 103)) 102)" "(contains? (set '(101 102 103)) 105)" "(contains? (set '(101 102 103)) 103)" "(contains? (set [101 102 103]) 102)" "(contains? (set [101 102 103]) 105)" "(defn true-false [x secuencias]\\r\\n    (for [y secuencias]\\r\\n      (if (contains? (set y) x)\\r\\n        true\\r\\n        )\\r\\n      )\\r\\n    \\r\\n    )" "(true-false 1 [[2 3][4 5][1 6]])" "(for [x (count [[2 3][4 5][1 6]])]\\r\\n    (for [z (first [[2 3][4 5][1 6]])]\\r\\n      (true-false z (rest [[2 3][4 5][1 6]]))    \\r\\n      )\\r\\n    )" "(for [z (first seqs)]\\r\\n    (true-false z (rest seqs))    \\r\\n    )" "(for [z (first [[2 3][4 5][1 6]])]\\r\\n    (true-false z (rest [[2 3][4 5][1 6]]))    \\r\\n    )" "(conj (list 1 2 3) (list 4 5))" "(concat (list 1 2 3) (list 4 5))" "(concat (list (rest (list 1 2 3)) (list (list 4 5) (list 6 7))))" "(+ 2 2)" "(contains? (set [1 2 3]) 2)" "(contains? (set [1 2 3 5]) 4)" "(contains? (set (list 1 2 3)) 2)" "(contains? (set (list 1 2 3)) 4)" "(contains? (set (list (list 1 2 3) (list 4 5))) 4)" "(defn true-false [x secuencia]\\r\\n    (lazy-seq\\r\\n      (for [y secuencia]\\r\\n        (contains? (set y) x)\\r\\n        )\\r\\n      )\\r\\n    )" "(true-false 2 (list (list 3 4) (list 4 2) (list 2 2)))" "(defn true-false [x secuencia]\\r\\n    (for [y secuencia]\\r\\n      (contains? (set y) x)\\r\\n      )\\r\\n    )" "(true-false 2 (list (list 3 4) (list 4 2) (list 2 2)))" "(defn true-false [x secuencia]\\r\\n    (for [y secuencia]\\r\\n      (contains? (set y) x)\\r\\n      )\\r\\n    )" "(true-false 3 (list (list 1 2 3) (list 3 3 1) (list 2 2 13232)))" "(defn hello [& seqs] seqs)" "(hello (list 1 2) (list 3 4) (list 5 6))" "(rest (list 1 2) (list 3 4) (list 5 6))" "(rest (list (list 1 2) (list 3 4) (list 5 6)))" "(concat (rest (first (list (list 1 2) (list 3 4) (list 5 6)))) (rest (list (list 1 2) (list 3 4) (list 5 6))))" "(concat (rest (first (list (list 0 1 2) (list 3 4) (list 5 6)))) (rest (list (list 1 2) (list 3 4) (list 5 6))))" "(defn search\\r\\n  \\"Dado un numero cualquiera de secuencias, cada una ya ordenada de menor a mayor, encontrar el numero\\r\\n   mas chico que aparezca en todas las secuencias, las secuencias pueden ser infinitas.\\"\\r\\n  [& seqs]\\r\\n  \\r\\n  (defn true-false [x secuencia]\\r\\n    (for [y secuencia]\\r\\n      (contains? (set y) x)\\r\\n      )\\r\\n    )\\r\\n  \\r\\n  (if (some false? (true-false (first (first seqs)) (rest seqs)))\\r\\n    (search (concat (list (rest (first seqs)))) (rest seqs))\\r\\n    (first (first seqs))\\r\\n    )\\r\\n  )" "(search (list 1 2 3 4 5) (list 3 4) (list 0 1 2 4))" "(defn search\\r\\n     [& seqs]\\r\\n     \\r\\n     (defn true-false [x secuencia]\\r\\n       (for [y secuencia]\\r\\n         (contains? (set y) x)\\r\\n         )\\r\\n       )\\r\\n     \\r\\n     (if (some false? (true-false (first (first seqs)) (rest seqs)))\\r\\n       \\"Hola\\"\\r\\n       (first (first seqs))\\r\\n       )\\r\\n     )" "(search (list 1 2 3 4 5) (list 3 4) (list 0 1 2 4))" "(search (list 1 2 3 4 5) (list 3 1) (list 0 1 2 4))" "(rest (list 1 2 3 4 5) (list 3 1) (list 0 1 2 4))" "(hello (list 1 2 3 4 5) (list 3 1) (list 0 1 2 4))" "(rest (list (list 1 2 3 4 5) (list 3 1) (list 0 1 2 4)))" "(defn hello [& seqs] (rest seqs))" "(hello (list 1 2 3 4 5) (list 3 1) (list 0 1 2 4))" "(defn hello [& seqs] (drop 1 seqs))" "(hello (list 1 2 3 4 5) (list 3 1) (list 0 1 2 4))" "(defn foo [x]\\r\\n        (if (< x 0)\\r\\n          (println \\"done\\")\\r\\n          \#(foo (do (println \:x x) (dec x)))))" "(trampoline foo 10)" "(defn true-false [x secuencia]\\r\\n    (for [y secuencia]\\r\\n      (contains? (set y) x)\\r\\n      )\\r\\n    )" "(defn search [& seqs] (if (some false? (true-false (first (first seqs)) (rest seqs)))\\r\\n    (trampoline search (concat (list (rest (first seqs)))) (rest seqs))\\r\\n    (first (first seqs))\\r\\n    ))" "(search (list 1 2 3) (list 2 3) (list 2))" "(defn search [& seqs] (if (some false? (true-false (first (first seqs)) (rest seqs)))\\r\\n       (search (concat (list (rest (first seqs)))) (rest seqs))\\r\\n       (first (first seqs))\\r\\n       ))" "(trampoline (list 1 2 3) (list 2 3) (list 2))" "(defn search [& seqs] \\n  (if (some false? (true-false (first (first seqs)) (rest seqs)))\\r\\n          \#(search (concat (list (rest (first seqs)))) (rest seqs))\\r\\n          (first (first seqs))\\r\\n          ))" "(trampoline search (list 1 2 3) (list 2 3) (list 2))" "(search (list 1 2 3) (list 2 3) (list 2))" "(defn search [& seqs] \\r\\n     (if (some false? (true-false (first (first seqs)) (rest seqs)))\\r\\n             \#(search (concat (list (rest (first seqs)))) (rest seqs))\\r\\n             (println (first (first seqs)))\\r\\n             ))" "(trampoline search (list 1 2 3) (list 2 3))" "(concat (list (rest (first (list (list 1 2 3) (list 2 3) (list 2 3))))) (rest (list (list 1 2 3) (list 2 3) (list 2 3))))" "(defn hello [& se] se)" "(hello (list (list 1 2 3) (list 4 5) (list 6 7)))" "(defn search2 [secuencias]\\r\\n    (if (some false? (true-false (first (first secuencias)) (rest secuencias)))\\r\\n      \#(search2 (concat (list (rest (first secuencias))) (rest secuencias)))\\r\\n      (first (first secuencias))\\r\\n      )\\r\\n    )" "(trampoline search2 (list 1 2 3) (list 2 3) (list 1 2))" "(trampoline search2 (list (list 1 2 3) (list 2 3) (list 1 2)))" "(trampoline search2 (list (list 1 2 3 4 5 6) (list 2 4 5) (list 0 1 3 5)))" "(trampoline search2 (list (list 1 2 3 4 5 6 7) (list 2 4 5 7) (list 0 1 3 5 7)))" "(nth [1 2 3 4 5] 3)" "(reduce (fn [m x] (assoc m x (inc (m x 0)))) {} (list 1 1 2 2 1))" "(reduce (fn [m x] (assoc m x (inc (m x 0)))) [] (list 1 1 2 2 1))" "(reduce \#(assoc %1 %2 (inc (%1 %2 0))) {} coll)" "(reduce \#(assoc %1 %2 (inc (%1 %2 0))) {} (list 1 1 2 2 1))" "(concat (list 1 2) (list 3 4))" "(defn tarta [x y sec temp]\\r\\n    (if (not (empty? sec))\\r\\n      (if (\= x (first sec))\\r\\n        (tarta x (+ 1 y) (rest sec) temp)\\r\\n        (tarta (first sec) 1 (rest sec) (concat temp (list x y)))\\r\\n        )\\r\\n      temp\\r\\n      )\\r\\n    )" "(tarta 1 1 (list 1 2 2 1) '())" "(defn tarta [x y sec temp]\\r\\n    (if (not (empty? sec))\\r\\n      (if (\= x (first sec))\\r\\n        (tarta x (+ 1 y) (rest sec) temp)\\r\\n        (tarta (first sec) 1 (rest sec) (concat temp (list x y)))\\r\\n        )\\r\\n      (concat temp (list x y))\\r\\n      )\\r\\n    )" "(tarta 1 1 (list 1 2 2 1) '())" "(defn tartamudeo\\r\\n  \\"Escriba una funcion que retorne una secuencia lazy que comprima el tartamudeo de una secuencia de numeros.\\r\\n   Comprimir el tartamudeo se refiere a que [1 1 1] se exprese como [3 1] y a su vez [3 1] se exprese como [1 3 1 1].\\r\\n\\r\\n   La funcion debe aceptar una secuencia inicial de numeros, y devolver una secuencia infinita de compresiones, donde\\r\\n   cada nuevo elemento es el elemento anterior comprimido.\\"\\r\\n  [secuencia]\\r\\n  \\r\\n  (defn tarta [x y sec temp]\\r\\n    (if (not (empty? sec))\\r\\n      (if (\= x (first sec))\\r\\n        (tarta x (+ 1 y) (rest sec) temp)\\r\\n        (tarta (first sec) 1 (rest sec) (concat temp (list x y)))\\r\\n        )\\r\\n      (concat temp (list x y))\\r\\n      )\\r\\n    )\\r\\n  \\r\\n  (lazy-seq\\r\\n    (tarta (first secuencia) 1 (rest secuencia) '())\\r\\n    )\\r\\n  )" "(take 3 (tartamudeo [1]))" "(tartamudeo [1 1 1 4 4])" "(defn tartamudeo\\r\\n  \\"Escriba una funcion que retorne una secuencia lazy que comprima el tartamudeo de una secuencia de numeros.\\r\\n   Comprimir el tartamudeo se refiere a que [1 1 1] se exprese como [3 1] y a su vez [3 1] se exprese como [1 3 1 1].\\r\\n\\r\\n   La funcion debe aceptar una secuencia inicial de numeros, y devolver una secuencia infinita de compresiones, donde\\r\\n   cada nuevo elemento es el elemento anterior comprimido.\\"\\r\\n  [secuencia]\\r\\n  \\r\\n  (defn tarta [x y sec temp]\\r\\n    (if (not (empty? sec))\\r\\n      (if (\= x (first sec))\\r\\n        (tarta x (+ 1 y) (rest sec) temp)\\r\\n        (tarta (first sec) 1 (rest sec) (concat temp (list y x)))\\r\\n        )\\r\\n      (concat temp (list y x))\\r\\n      )\\r\\n    )\\r\\n  \\r\\n  (lazy-seq\\r\\n    (tarta (first secuencia) 1 (rest secuencia) '())\\r\\n    )\\r\\n  )" "(tartamudeo [1 1 1 4 4])" "(tartamudeo [1 1 1 4 4 5 1 1 1])" "(tartamudeo [1 2 2 3 3 3 4 4 4 4 5 5 5 5 5])" "(require '(code-katas-2.core))" "(require '(code-katas-2.core-test))" "(iterate inc [1 2 3 4])" "(take 3 (iterate inc 3))" "(defn tartamudeo\\r\\n  \\"Escriba una funcion que retorne una secuencia lazy que comprima el tartamudeo de una secuencia de numeros.\\r\\n   Comprimir el tartamudeo se refiere a que [1 1 1] se exprese como [3 1] y a su vez [3 1] se exprese como [1 3 1 1].\\r\\n\\r\\n   La funcion debe aceptar una secuencia inicial de numeros, y devolver una secuencia infinita de compresiones, donde\\r\\n   cada nuevo elemento es el elemento anterior comprimido.\\"\\r\\n  [secuencia]\\r\\n  \\r\\n  (defn tarta [x y sec temp]\\r\\n    (if (not (empty? sec))\\r\\n      (if (\= x (first sec))\\r\\n        (tarta x (+ 1 y) (rest sec) temp)\\r\\n        (tarta (first sec) 1 (rest sec) (concat temp (list y x)))\\r\\n        )\\r\\n      (concat temp (list y x))\\r\\n      )\\r\\n    )\\r\\n  \\r\\n  (lazy-seq\\r\\n    (iterate (tarta (first secuencia) 1 (rest secuencia) '()) secuencia)\\r\\n    )\\r\\n  )" "(take 3 (tartamudeo [1]))" "(defn tartamudeo\\r\\n  \\"Escriba una funcion que retorne una secuencia lazy que comprima el tartamudeo de una secuencia de numeros.\\r\\n   Comprimir el tartamudeo se refiere a que [1 1 1] se exprese como [3 1] y a su vez [3 1] se exprese como [1 3 1 1].\\r\\n\\r\\n   La funcion debe aceptar una secuencia inicial de numeros, y devolver una secuencia infinita de compresiones, donde\\r\\n   cada nuevo elemento es el elemento anterior comprimido.\\"\\r\\n  [secuencia]\\r\\n  \\r\\n  (defn tarta [x y sec temp]\\r\\n    (if (not (empty? sec))\\r\\n      (if (\= x (first sec))\\r\\n        (tarta x (+ 1 y) (rest sec) temp)\\r\\n        (tarta (first sec) 1 (rest sec) (concat temp (list y x)))\\r\\n        )\\r\\n      (concat temp (list y x))\\r\\n      )\\r\\n    )\\r\\n  \\r\\n  (lazy-seq\\r\\n    (iterate \#(tarta (first secuencia) 1 (rest secuencia) '()) secuencia)\\r\\n    )\\r\\n  )" "(take 3 (tartamudeo [1]))" "(defn tartamudeo\\r\\n  \\"Escriba una funcion que retorne una secuencia lazy que comprima el tartamudeo de una secuencia de numeros.\\r\\n   Comprimir el tartamudeo se refiere a que [1 1 1] se exprese como [3 1] y a su vez [3 1] se exprese como [1 3 1 1].\\r\\n\\r\\n   La funcion debe aceptar una secuencia inicial de numeros, y devolver una secuencia infinita de compresiones, donde\\r\\n   cada nuevo elemento es el elemento anterior comprimido.\\"\\r\\n  [secuencia]\\r\\n  \\r\\n  (defn tarta [x y sec temp]\\r\\n    (if (not (empty? sec))\\r\\n      (if (\= x (first sec))\\r\\n        (tarta x (+ 1 y) (rest sec) temp)\\r\\n        (tarta (first sec) 1 (rest sec) (concat temp (list y x)))\\r\\n        )\\r\\n      (concat temp (list y x))\\r\\n      )\\r\\n    )\\r\\n  \\r\\n  (lazy-seq\\r\\n    (iterate \#(fn (tarta (first secuencia) 1 (rest secuencia) '())) (first secuencia))\\r\\n    )\\r\\n  )" "(defn tartamudeo\\r\\n  \\"Escriba una funcion que retorne una secuencia lazy que comprima el tartamudeo de una secuencia de numeros.\\r\\n   Comprimir el tartamudeo se refiere a que [1 1 1] se exprese como [3 1] y a su vez [3 1] se exprese como [1 3 1 1].\\r\\n\\r\\n   La funcion debe aceptar una secuencia inicial de numeros, y devolver una secuencia infinita de compresiones, donde\\r\\n   cada nuevo elemento es el elemento anterior comprimido.\\"\\r\\n  [secuencia]\\r\\n  \\r\\n  (defn tarta [x y sec temp]\\r\\n    (if (not (empty? sec))\\r\\n      (if (\= x (first sec))\\r\\n        (tarta x (+ 1 y) (rest sec) temp)\\r\\n        (tarta (first sec) 1 (rest sec) (concat temp (list y x)))\\r\\n        )\\r\\n      (concat temp (list y x))\\r\\n      )\\r\\n    )\\r\\n  \\r\\n  (lazy-seq\\r\\n    (iterate \#(fn (tarta (first (first secuencia)) 1 (rest (first secuencia)) '())) secuencia)\\r\\n    )\\r\\n  )" "(take 5 (iterate inc 1))" "(defn tartamudeo\\r\\n  \\"Escriba una funcion que retorne una secuencia lazy que comprima el tartamudeo de una secuencia de numeros.\\r\\n   Comprimir el tartamudeo se refiere a que [1 1 1] se exprese como [3 1] y a su vez [3 1] se exprese como [1 3 1 1].\\r\\n\\r\\n   La funcion debe aceptar una secuencia inicial de numeros, y devolver una secuencia infinita de compresiones, donde\\r\\n   cada nuevo elemento es el elemento anterior comprimido.\\"\\r\\n  [secuencia]\\r\\n  \\r\\n  (defn tarta [x y sec temp]\\r\\n    (if (not (empty? sec))\\r\\n      (if (\= x (first sec))\\r\\n        (tarta x (+ 1 y) (rest sec) temp)\\r\\n        (tarta (first sec) 1 (rest sec) (concat temp (list y x)))\\r\\n        )\\r\\n      (concat temp (list y x))\\r\\n      )\\r\\n    )\\r\\n  \\r\\n  (lazy-seq\\r\\n    (iterate \#(fn (tarta (first secuencia) 1 (rest secuencia) '())) '())\\r\\n    )\\r\\n  )" "(defn tartamudeo\\r\\n  \\"Escriba una funcion que retorne una secuencia lazy que comprima el tartamudeo de una secuencia de numeros.\\r\\n   Comprimir el tartamudeo se refiere a que [1 1 1] se exprese como [3 1] y a su vez [3 1] se exprese como [1 3 1 1].\\r\\n\\r\\n   La funcion debe aceptar una secuencia inicial de numeros, y devolver una secuencia infinita de compresiones, donde\\r\\n   cada nuevo elemento es el elemento anterior comprimido.\\"\\r\\n  [secuencia]\\r\\n  \\r\\n  (defn tarta [x y sec temp]\\r\\n    (if (not (empty? sec))\\r\\n      (if (\= x (first sec))\\r\\n        (tarta x (+ 1 y) (rest sec) temp)\\r\\n        (tarta (first sec) 1 (rest sec) (concat temp (list y x)))\\r\\n        )\\r\\n      (concat temp (list y x))\\r\\n      )\\r\\n    )\\r\\n  \\r\\n  (lazy-seq\\r\\n    (iterate (tarta (first secuencia) 1 (rest secuencia) '()) '())\\r\\n    )\\r\\n  )" "(take 3 (tartamudeo [1]))" "(defn tartamudeo\\r\\n  \\"Escriba una funcion que retorne una secuencia lazy que comprima el tartamudeo de una secuencia de numeros.\\r\\n   Comprimir el tartamudeo se refiere a que [1 1 1] se exprese como [3 1] y a su vez [3 1] se exprese como [1 3 1 1].\\r\\n\\r\\n   La funcion debe aceptar una secuencia inicial de numeros, y devolver una secuencia infinita de compresiones, donde\\r\\n   cada nuevo elemento es el elemento anterior comprimido.\\"\\r\\n  [secuencia]\\r\\n  \\r\\n  (defn tarta [x y sec temp]\\r\\n    (if (not (empty? sec))\\r\\n      (if (\= x (first sec))\\r\\n        (tarta x (+ 1 y) (rest sec) temp)\\r\\n        (tarta (first sec) 1 (rest sec) (concat temp (list y x)))\\r\\n        )\\r\\n      (concat temp (list y x))\\r\\n      )\\r\\n    )\\r\\n  \\r\\n  (iterate (tarta (first secuencia) 1 (rest secuencia) '()) '())\\r\\n    \\r\\n  )" "(take 3 (tartamudeo [1]))" "(defn tartamudeo\\r\\n  \\"Escriba una funcion que retorne una secuencia lazy que comprima el tartamudeo de una secuencia de numeros.\\r\\n   Comprimir el tartamudeo se refiere a que [1 1 1] se exprese como [3 1] y a su vez [3 1] se exprese como [1 3 1 1].\\r\\n\\r\\n   La funcion debe aceptar una secuencia inicial de numeros, y devolver una secuencia infinita de compresiones, donde\\r\\n   cada nuevo elemento es el elemento anterior comprimido.\\"\\r\\n  [secuencia]\\r\\n  \\r\\n  (defn tarta [x y sec temp]\\r\\n    (if (not (empty? sec))\\r\\n      (if (\= x (first sec))\\r\\n        (tarta x (+ 1 y) (rest sec) temp)\\r\\n        (tarta (first sec) 1 (rest sec) (concat temp (list y x)))\\r\\n        )\\r\\n      (concat temp (list y x))\\r\\n      )\\r\\n    )\\r\\n  \\r\\n  (defn tarta2 [secuencia2] (tarta (first secuencia2) 1 (rest secuencia2) '()))\\r\\n  \\r\\n  (iterate tarta2 secuencia)\\r\\n    \\r\\n  )" "(take 3 (tartamudeo [1]))" "(count (nth (tartamudeo [3 2]) 15))" "(nth (tartamudeo [1]) 6)" "(nth (tartamudeo [1]) 7)" "(count (nth (tartamudeo [3 2]) 16))" "(take 4 (tartamudeo [1]))" "(take 1 (tartamudeo [1]))" "(tarta (first [1]) 1 (rest [1]) '())^" "(tarta (first [1]) 1 (rest [1]) '())" "(take 10 (tartamudeo [3 2]))" "(take 5 (tartamudeo [3 2]))" "(take 4 (tartamudeo [3 2]))"]
eclipse.preferences.version=1
