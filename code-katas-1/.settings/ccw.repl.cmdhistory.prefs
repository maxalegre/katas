cmdhistory=["(alength [1 2 3 4 5])" "(doc alength)" "(count [1 2 3 4 5])" "(for i (range 5) println i)" "(for [i (range 5) println i])" "(for [i (range 5)] println i)" "(for [i (range 5)] (println i))" "(let (filter odd? [1 2 3]) [1 2 3])" "(let [(filter odd? [1 2 3])] [1 2 3])" "(let [[1 2 3] odd?] [1 2 3])" "(for [x [1 2 3] \:when (odd? x)] x)" "(\:r {\:r 2})" "(if (nil? [\:r {\:r true}]) true nil)" "(if (nil? [\:r {\:r nil}]) true nil)" "(if (nil? [\:r {\:r nil}]) \\"true\\" \\"nil\\")" "(nil? [\:r {\:r nil}])" "(nil? [\:r {\:r \\"xvznil\\"}])" "(nil? nil)" "[\:r {\:r nil}]" "(\:r {\:r nil})" "(if (nil? (\:r {\:r nil})) true nil)" "(require 'code-katas-1.core-test)" "(in-ns 'code-katas-1.core-test)" "(run-tests)" "(in-ns 'code-katas-1.core)" "(require 'code-katas-1.core-test)" "(run-tests)" "(in-ns 'code-katas-1.core-test)" "(in-ns 'code-katas-1.core)" "(require 'code-katas-1.core)" "(take-while (not\= 3 5) 1)" "(take-while neg? [3 -2 -1 0 1 2 3])" "(take-while (not\= start end) 1)" "(take-while (not\= 1 5) 1)" "(take-while (not\= 1 3) [1 7 3 4 5 6])" "(take-while neg? [3 -2 -1 0 1 2 3])" "(take-while neg? [-3 -2 1 -6 1 2 3])" "(for [[x y] '(2 5) \:while (not\= start end)] start)" "(for [[x y] '(2 5) \:while (not\= x y)] x)" "(for [(x y) [2 5] \:while (not\= x y)] x)" "(for [[x y] '([2 5]) \:while (not\= x y)] x)" "(range 3 7)" "(reduce cons [1 2 3] [4 5 6])" "(reduce conj [1 2 3] [4 5 6])" "(run-tests)" "(if (nil? (\:a {\:a nil \:b 2})) true nil)" "(if (nil? (\:a {\:a nil \:b 2})) \\"xzcxzc\\" nil)" "(\:x {\:a nil \:b 2})" "(if (contains? \:a {\:a nil \:b 2}) (if (nil? (\:a {\:a nil \:b 2})) true nil) nil)" "(if (contains? {\:a nil \:b 2} \:a) (if (nil? (\:a {\:a nil \:b 2})) true nil) nil)" "(if (contains? {\:a nil \:b 2} \:k) (if (nil? (\:a {\:a nil \:b 2})) true nil) \\"eueueu\\")" "(if (contains? {\:a nil \:b 2} \:k) (if (nil? (\:a {\:a nil \:b 2})) \\"erere\\" nil) \\"eueueu\\")" "(if (contains? {\:a nil \:b 2} \:a) (if (nil? (\:a {\:a nil \:b 2})) true nil) \\"eueueu\\")" "(if (contains? {\:a nil \:b 2} \:a) (if (nil? (\:a {\:a nil \:b 2})) \\"erere\\" nil) \\"eueueu\\")" "(loop [x 10]\\r\\n  (when (> x 1)\\r\\n    (println x)\\r\\n    (recur (- x 2))))" "(loop [x 10] (println x))" "(loop [x 10] println x)" "(loop [x 10] x)" "(loop [x 70] x)" "(loop [i 0]  \\r\\n  (when (< i 5)    \\r\\n    (println i)    \\r\\n    (recur (inc i)); loop i will take this value\\r\\n))" "(loop [i 0]   \\r\\n    (println i)    \\r\\n    (recur (inc i)); loop i will take this value\\r\\n)" "(\= 2 2)" "(loop [i 0]  \\r\\n  (when (< i 5)    \\r\\n    (println i)    \\r\\n    (recur (inc i)); loop i will take this value\\r\\n))" "(loop [i 5]  \\r\\n  (when (< i 10)    \\r\\n    (println i)    \\r\\n    (recur (inc i)); loop i will take this value\\r\\n))" "(loop [i 5]  \\r\\n     (when (< i 10)    \\r\\n       (conj i [])    \\r\\n       (recur (inc i)); loop i will take this value\\r\\n   ))" "(loop [i 5]  \\r\\n     (when (< i 10)    \\r\\n       i    \\r\\n       (recur (inc i)); loop i will take this value\\r\\n   ))" "(loop [i 5]  \\r\\n     (when (< i 10)    \\r\\n       (println i) \\n       (list* i)\\r\\n       (recur (inc i)); loop i will take this value\\r\\n   ))" "(dotimes [i 4] (prn i))" "(loop [i 5] (when (< i 10) (conj i []) (recur (inc i)) ))" "(loop [i 5] (when (< i 10) (println i) (recur (inc i)) ))" "(repeatedly \#(rand-int 100))" "(def integers (iterate inc 5))" "(iterate inc 5)" "(take 5 integers)" "(take (- end start) (iterate inc 5))" "(take (- 10 5) (iterate inc 5))" "(if (< 5 11) (take (- 11 5) (iterate inc 5)) \\"Inicio debe ser mas peque\u00F1o que final\\")" "(if (< 10 5) (take (- 5 10) (iterate inc 10)) \\"Inicio debe ser mas peque\u00F1o que final\\")" "(for [x [1 2 3 4 5]] x)" "(distinct [1 2 1 3 4 6 2] )" "(defn max-value\\r\\n  \\"Escribir una funcion que reciba un numero variable de parametros\\r\\n   y retorne el que tenga el valor mayor\\r\\n   Restricciones\: max y max-key\\"\\r\\n  [& args]\\r\\n  (println &)\\r\\n  (println args)\\r\\n  )" "(defn max-value\\r\\n  \\"Escribir una funcion que reciba un numero variable de parametros\\r\\n   y retorne el que tenga el valor mayor\\r\\n   Restricciones\: max y max-key\\"\\r\\n  [& args]\\r\\n  (println args)\\r\\n  )" "(let [[first-element] [1 2 3 4]])" "(let [x (first [1 2 3 4])])" "(let [x (first @items)] x)" "(let [x (first [5 6 7 8])] x)" "(first [5 6 7 8])" "(def a 0)" "a" "(a)" "(conj 1 a)" "(class? a)" "(type a)" "(def a (0))" "(def b (0))" "(def my-list (0))" "(def a (list 0))" "a" "(conj a (2 3 4))" "(type a)" "(conj a '(2 3 4))" "a" "(def b '(5))" "b" "(def b (concat b '(6 7 9)))" "b" "(def b (concat '(6 7 9) b))" "b" "(def a '(0))" "a" "(for [x [3 8 4 9 2]] (if (> x (first a)) (concat x a) ) )" "(for [x args] (if (> x (first a)) (concat '(x) a) ) )" "(for [x [3 8 4 9 2]] (if (> x (first a)) (concat '(x) a) ) )" "a" "(for [x [3 8 4 9 2]] (if (> x (first a)) (concat (x) a) ) )" "(for [x [3 8 4 9 2]] (if (> x (first a)) (conj a x) ) )" "(for [x [3 8 4 9 2]] (if (> x (first a)) (conj x a) ) )" "(def a {\:max 0})" "a" "(\:max a)" "(if (> x (\:max a)) \\"TOTOTO\\")" "(if (> 5 (\:max a)) \\"MEMEME\\")" "(if (> 5 (\:max a)) (assoc a \:max \\"IEIEIE\\"))" "a" "(for [x [1 3 8 2 9]] (if (> x (\:max a)) (assoc a \:max x) ) )" "(subvec [1 2 3] (first [1 2 3]) )" "(defn tete [q] (println q q q))" "(tete \\"wqewqe\\")" "(defn max-value2 [maxim pmts] (if (> (first pmts) maxim) (max-value2 (first pmts) (subvec pmts (first pmts))) (max-value2 maxim (subvec pmts (first pmts))) ) )" "(max-value2 0 [3 5 1 8 5])" "(subvec [3 5 1 8 5] (first [3 5 1 8 5]))" "(first [3 5 1 8 5])" "(drop 1 [3 5 1 8 5])" "(defn max-value2 [maxim pmts] (if (> (first pmts) maxim) (max-value2 (first pmts) (drop 1 pmts)) (max-value2 maxim (drop 1 pmts)) ) )" "(max-value2 0 [3 5 1 8 5])" "(drop 1 [3 5 1 8 5])" "(drop 1 (5 1 8 5))" "(into [] (drop 1 (5 1 8 5)))" "(into [] (drop 1 [3 5 1 8 5]))" "(defn max-value2 [maxim pmts] \\r\\n    (if (> (first pmts) maxim) \\r\\n      (max-value2 (first pmts) (into [] (drop 1 pmts))) \\r\\n      (max-value2 maxim (into [](drop 1 pmts))) \\r\\n      ) \\r\\n    )" "(max-value2 0 [3 5 1 8 5])" "(if (> (first [3 5 1 8 5]) 0) \\r\\n      (into [] (drop 1 [3 5 1 8 5]))\\r\\n      (println \\"WQE\\") \\r\\n      )" "(defn max-value2 [maxim pmts]\\r\\n    (if (not (empty? pmts))\\r\\n      (if (> (first pmts) maxim) \\r\\n        (max-value2 (first pmts) (into [] (drop 1 pmts))) \\r\\n        (max-value2 maxim (into [](drop 1 pmts))) \\r\\n        ) \\r\\n    )\\r\\n    \\"qweq\\"\\r\\n    )" "(max-value2 0 [3 5 1 8 5])" "(defn max-value2 [maxim pmts]\\r\\n       (if (not (empty? pmts))\\r\\n         (if (> (first pmts) maxim) \\r\\n           (max-value2 (first pmts) (into [] (drop 1 pmts))) \\r\\n           (max-value2 maxim (into [](drop 1 pmts))) \\r\\n           )\\n         maxim\\r\\n       )\\r\\n       )" "(max-value2 0 [1 5 2 8 3])" "(max-value2 0 [1 5 2 8 5 8765 4 4 767 345 765674 67 86867 87 3])"]
eclipse.preferences.version=1
